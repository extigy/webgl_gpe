<!DOCTYPE html>
<html>
  <head>
    <title>WebGL GPE</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" href="gpe.css">
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
    </script>
    <script id="shader-fs-show" type="x-shader/x-fragment">
        precision highp float;
        precision highp sampler2D;
        uniform sampler2D s_psi;
        varying vec2 vTexCoord;
        float cmpxmag(in vec2 c) {
            return sqrt(c.x * c.x + c.y * c.y);
        }
        vec2 unpackCmpx( in vec4 rgba ) {
            vec2 bitSh = vec2( 0.00390625, 1.0 );
            return vec2(dot(rgba.xy,bitSh),dot(rgba.zw, bitSh))*5. - 2.5;
        }
        void main(void) {
            vec2 psi = unpackCmpx(texture2D(s_psi, vTexCoord));
            float i = cmpxmag(psi);
            float a = atan(psi.y, psi.x)*.955 + 3.;
            gl_FragColor = vec4(i*clamp(abs(a - 3.) - 1., 0., 1.),i*clamp(2. - abs(a - 2.), 0., 1.),i*clamp(2. - abs(a - 4.), 0., 1.), 1.);
        }
    </script>
    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec2 aPos;
        attribute vec2 aTexCoord;
        varying   vec2 vTexCoord;
        void main(void) {
            gl_Position = vec4(aPos, 0., 1.);
            vTexCoord = aTexCoord;
        }
    </script>
    <script id="shader-fs-dpsi" type="x-shader/x-fragment">
        precision highp float;
        precision highp sampler2D;
        uniform sampler2D s_psi;
        uniform sampler2D s_k;
        uniform int kstep;
        uniform int addPot;
        uniform int addTrap;
        uniform float addPot_x;
        uniform float addPot_y;
        uniform float addPot_r;
        uniform float dx2;
        uniform float dt;
        uniform float gamma;
        varying vec2 vTexCoord;
        const float d = 1./256.;
        vec4 packCmpx( in vec2 value ) {
            const vec2 bit_mask = vec2( 0.0, 0.00390625 );
            const vec2 mult_vec = vec2( 65280.0, 255.0 );
            value = (value + 2.5)/5.;
            vec2 res1 = mod( value.x * mult_vec, vec2( 256 ) ) / vec2( 255 );
            vec2 res2 = mod( value.y * mult_vec, vec2( 256 ) ) / vec2( 255 );
            res1 -= res1.xx * bit_mask;
            res2 -= res2.xx * bit_mask;
            return vec4(res1,res2);
        }
        vec2 unpackCmpx( in vec4 rgba ) {
            vec2 bitSh = vec2( 0.00390625, 1.0 );
            return vec2(dot(rgba.xy,bitSh),dot(rgba.zw, bitSh))*5. - 2.5;
        }
        vec2 cmpxmul(in vec2 a, in vec2 b) {
            return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);
        }
        void main(void) {
            vec2 eye = vec2(0., 1.);
            vec2 psi = unpackCmpx(texture2D(s_psi, vTexCoord));
            vec2 psi_pdy = unpackCmpx(texture2D(s_psi, vec2(vTexCoord.x, vTexCoord.y + d)));
            vec2 psi_mdy = unpackCmpx(texture2D(s_psi, vec2(vTexCoord.x, vTexCoord.y - d)));
            vec2 psi_pdx = unpackCmpx(texture2D(s_psi, vec2(vTexCoord.x + d, vTexCoord.y)));
            vec2 psi_mdx = unpackCmpx(texture2D(s_psi, vec2(vTexCoord.x - d, vTexCoord.y)));

            if (kstep > 1){
                vec2 k = unpackCmpx(texture2D(s_k, vTexCoord));
                vec2 k_pdy = unpackCmpx(texture2D(s_k, vec2(vTexCoord.x, vTexCoord.y + d)));
                vec2 k_mdy = unpackCmpx(texture2D(s_k, vec2(vTexCoord.x, vTexCoord.y - d)));
                vec2 k_pdx = unpackCmpx(texture2D(s_k, vec2(vTexCoord.x + d, vTexCoord.y)));
                vec2 k_mdx = unpackCmpx(texture2D(s_k, vec2(vTexCoord.x - d, vTexCoord.y)));
                if (kstep == 4){
                    psi += k;
                    psi_pdy += k_pdy;
                    psi_mdy += k_mdy;
                    psi_pdx += k_pdx;
                    psi_mdx += k_mdx;
                } else {
                    psi += 0.5*k;
                    psi_pdy += 0.5*k_pdy;
                    psi_mdy += 0.5*k_mdy;
                    psi_pdx += 0.5*k_pdx;
                    psi_mdx += 0.5*k_mdx;
                }
            }

            vec2 dpsi_H = -0.5*(psi_pdy + psi_mdy + psi_pdx + psi_mdx - 4.*psi)/dx2  + (psi.x*psi.x + psi.y*psi.y)*psi - psi;
            if(addPot > 0){
                dpsi_H += 5.*exp(-64.*64.*(vTexCoord.x-addPot_x)*(vTexCoord.x-addPot_x)/addPot_r 
                            - 64.*64.*(vTexCoord.y-addPot_y)*(vTexCoord.y-addPot_y)/addPot_r)*psi;
            }
            if(addTrap > 0){
                dpsi_H += 10.*((vTexCoord.x-0.5)*(vTexCoord.x-0.5) + (vTexCoord.y-0.5)*(vTexCoord.y-0.5))*psi;
            }
            vec2 dpsi = cmpxmul(dpsi_H,-gamma-eye)*dt;
            gl_FragColor = packCmpx(dpsi);
        }
    </script>
    <script id="shader-fs-step" type="x-shader/x-fragment">
        precision highp float;
        precision highp sampler2D;
        uniform sampler2D s_psi;
        uniform sampler2D s_k1;
        uniform sampler2D s_k2;
        uniform sampler2D s_k3;
        uniform sampler2D s_k4;
        uniform int addVortex;
        uniform int reset;
        uniform float addVortex_x;
        uniform float addVortex_y;
        varying vec2 vTexCoord;
        const float d = 1./256.;
        vec4 packCmpx( in vec2 value ) {
            const vec2 bit_mask = vec2( 0.0, 0.00390625 );
            const vec2 mult_vec = vec2( 65280.0, 255.0 );
            value = (value + 2.5)/5.;
            vec2 res1 = mod( value.x * mult_vec, vec2( 256 ) ) / vec2( 255 );
            vec2 res2 = mod( value.y * mult_vec, vec2( 256 ) ) / vec2( 255 );
            res1 -= res1.xx * bit_mask;
            res2 -= res2.xx * bit_mask;
            return vec4(res1,res2);
        }
        vec2 unpackCmpx( in vec4 rgba ) {
            vec2 bitSh = vec2( 0.00390625, 1.0 );
            return vec2(dot(rgba.xy,bitSh),dot(rgba.zw, bitSh))*5. - 2.5;
        }
        vec2 cmpxmul(in vec2 a, in vec2 b) {
            return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);
        }
        void main(void) {
            vec2 psi = unpackCmpx(texture2D(s_psi, vTexCoord));
            vec2 k1 = unpackCmpx(texture2D(s_k1, vTexCoord));
            vec2 k2 = unpackCmpx(texture2D(s_k2, vTexCoord));
            vec2 k3 = unpackCmpx(texture2D(s_k3, vTexCoord));
            vec2 k4 = unpackCmpx(texture2D(s_k4, vTexCoord));

            vec2 psi_new = psi + k1/6. + k2/3. + k3/3. + k4/6.;
            if (addVortex==1){
                psi_new = cmpxmul(psi_new,vec2(cos(atan(vTexCoord.y-addVortex_y,vTexCoord.x-addVortex_x)),
                            -sin(atan(vTexCoord.y-addVortex_y,vTexCoord.x-addVortex_x))));
            }else if (addVortex==-1){
                psi_new = cmpxmul(psi_new,vec2(cos(-atan(vTexCoord.y-addVortex_y,vTexCoord.x-addVortex_x)),
                            -sin(-atan(vTexCoord.y-addVortex_y,vTexCoord.x-addVortex_x))));
            }
            if (reset==1){
                psi_new = vec2(1.0,0.0);
            }
            gl_FragColor = packCmpx(psi_new);
        }
    </script>
  </head>
  <body>
    <h1>WebGL GPE</h1>
    <h3>A demo by <a href="https://gwstagg.co.uk">George Stagg</a></h3>
    <canvas id="GPE" width="256" height="256"></canvas><br>
    <img src="gpe.svg" width="60%">
    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
    <script src="dat.gui.js"></script>
    <script src="gpe.js?v=0.06"></script>
  </body>
</html>
