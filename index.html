<!DOCTYPE html>
<html>
  <head>
    <title>WebGL GPE</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" href="gpe.css">
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
    </script>
    <script id="shader-fs-show" type="x-shader/x-fragment">
        precision highp float;
        uniform sampler2D psi_re;
        uniform sampler2D psi_im;
        varying vec2 vTexCoord;
        float cmpxmag(in vec2 c) {
            return sqrt(c.x * c.x + c.y * c.y);
        }
        float unpackFloat( vec4 rgba ) {
            const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );
            return dot( rgba, bitSh )*5. - 2.5;
        }
        void main(void) {
            vec2 psi = vec2(unpackFloat(texture2D(psi_re, vTexCoord)),unpackFloat(texture2D(psi_im, vTexCoord)));
            float i = cmpxmag(psi);
            float a = atan(psi.y, psi.x)*.955 + 3.;
            gl_FragColor = vec4(i*clamp(abs(a - 3.) - 1., 0., 1.),i*clamp(2. - abs(a - 2.), 0., 1.),i*clamp(2. - abs(a - 4.), 0., 1.), 1.);
            //gl_FragColor = vec4(psi.y,0.,0.,1.);
        }
    </script>
    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec2 aPos;
        attribute vec2 aTexCoord;
        varying   vec2 vTexCoord;
        void main(void) {
            gl_Position = vec4(aPos, 0., 1.);
            vTexCoord = aTexCoord;
        }
    </script>
    <script id="shader-fs-dpsi" type="x-shader/x-fragment">
        precision highp float;
        uniform sampler2D psi_re;
        uniform sampler2D psi_im;
        uniform sampler2D k_re;
        uniform sampler2D k_im;
        uniform int kstep;
        uniform int reim;
        uniform int addPot;
        uniform float addPot_x;
        uniform float addPot_y;
        uniform float addPot_r;
        uniform float dx2;
        uniform float dt;
        uniform float gamma;
        varying vec2 vTexCoord;
        const float d = 1./256.;
        vec4 packFloat( float value ) {
            const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );
            const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );
            value = (value + 2.5)/5.;
            vec4 res = mod( value * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );
            res -= res.xxyz * bit_mask;
            return res;
        }
        float unpackFloat( vec4 rgba ) {
            const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );
            return dot( rgba, bitSh )*5. - 2.5;
        }
        vec2 cmpxmul(in vec2 a, in vec2 b) {
            return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);
        }
        void main(void) {
            vec2 eye = vec2(0., 1.);
            vec2 psi = vec2(unpackFloat(texture2D(psi_re, vTexCoord)), unpackFloat(texture2D(psi_im, vTexCoord)));
            vec2 psi_pdy = vec2(unpackFloat(texture2D(psi_re, vec2(vTexCoord.x, vTexCoord.y + d))),
                            unpackFloat(texture2D(psi_im, vec2(vTexCoord.x, vTexCoord.y + d))));
            vec2 psi_mdy = vec2(unpackFloat(texture2D(psi_re, vec2(vTexCoord.x, vTexCoord.y - d))),
                            unpackFloat(texture2D(psi_im, vec2(vTexCoord.x, vTexCoord.y - d))));
            vec2 psi_pdx = vec2(unpackFloat(texture2D(psi_re, vec2(vTexCoord.x + d, vTexCoord.y))),
                            unpackFloat(texture2D(psi_im, vec2(vTexCoord.x + d, vTexCoord.y))));
            vec2 psi_mdx = vec2(unpackFloat(texture2D(psi_re, vec2(vTexCoord.x - d, vTexCoord.y))),
                            unpackFloat(texture2D(psi_im, vec2(vTexCoord.x - d, vTexCoord.y))));

            if (kstep > 1){
                vec2 k = vec2(unpackFloat(texture2D(k_re, vTexCoord)), unpackFloat(texture2D(k_im, vTexCoord)));
                vec2 k_pdy = vec2(unpackFloat(texture2D(k_re, vec2(vTexCoord.x, vTexCoord.y + d))),
                                unpackFloat(texture2D(k_im, vec2(vTexCoord.x, vTexCoord.y + d))));
                vec2 k_mdy = vec2(unpackFloat(texture2D(k_re, vec2(vTexCoord.x, vTexCoord.y - d))),
                                unpackFloat(texture2D(k_im, vec2(vTexCoord.x, vTexCoord.y - d))));
                vec2 k_pdx = vec2(unpackFloat(texture2D(k_re, vec2(vTexCoord.x + d, vTexCoord.y))),
                                unpackFloat(texture2D(k_im, vec2(vTexCoord.x + d, vTexCoord.y))));
                vec2 k_mdx = vec2(unpackFloat(texture2D(k_re, vec2(vTexCoord.x - d, vTexCoord.y))),
                                unpackFloat(texture2D(k_im, vec2(vTexCoord.x - d, vTexCoord.y))));
                if (kstep == 4){
                    psi += k;
                    psi_pdy += k_pdy;
                    psi_mdy += k_mdy;
                    psi_pdx += k_pdx;
                    psi_mdx += k_mdx;
                } else {
                    psi += 0.5*k;
                    psi_pdy += 0.5*k_pdy;
                    psi_mdy += 0.5*k_mdy;
                    psi_pdx += 0.5*k_pdx;
                    psi_mdx += 0.5*k_mdx;
                }
            }

            vec2 dpsi_H = -0.5*(psi_pdy + psi_mdy + psi_pdx + psi_mdx - 4.*psi)/dx2  + (psi.x*psi.x + psi.y*psi.y)*psi - psi;
            if(addPot > 0){
                dpsi_H += 20.*exp(-64.*64.*(vTexCoord.x-addPot_x)*(vTexCoord.x-addPot_x)/addPot_r 
                            - 64.*64.*(vTexCoord.y-addPot_y)*(vTexCoord.y-addPot_y)/addPot_r)*psi;
            }
            vec2 dpsi = cmpxmul(dpsi_H,-gamma-eye)*dt;

            if(reim == 0){
                gl_FragColor = packFloat(dpsi.x);
            } else {
                gl_FragColor = packFloat(dpsi.y);
            }
        }
    </script>
    <script id="shader-fs-step" type="x-shader/x-fragment">
        precision highp float;
        uniform sampler2D psi_re;
        uniform sampler2D psi_im;
        uniform sampler2D k1_re;
        uniform sampler2D k1_im;
        uniform sampler2D k2_re;
        uniform sampler2D k2_im;
        uniform sampler2D k3_re;
        uniform sampler2D k3_im;
        uniform sampler2D k4_re;
        uniform sampler2D k4_im;
        uniform int reim;
        uniform int addVortex;
        uniform int reset;
        uniform float addVortex_x;
        uniform float addVortex_y;
        varying vec2 vTexCoord;
        const float d = 1./256.;
        vec4 packFloat( float value ) {
            const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );
            const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );
            value = (value + 2.5)/5.;
            vec4 res = mod( value * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );
            res -= res.xxyz * bit_mask;
            return res;
        }
        float unpackFloat( vec4 rgba ) {
            const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );
            return dot( rgba, bitSh )*5. - 2.5;
        }
        vec2 cmpxmul(in vec2 a, in vec2 b) {
            return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);
        }
        void main(void) {
            vec2 psi = vec2(unpackFloat(texture2D(psi_re, vTexCoord)), unpackFloat(texture2D(psi_im, vTexCoord)));
            vec2 k1 = vec2(unpackFloat(texture2D(k1_re, vTexCoord)), unpackFloat(texture2D(k1_im, vTexCoord)));
            vec2 k2 = vec2(unpackFloat(texture2D(k2_re, vTexCoord)), unpackFloat(texture2D(k2_im, vTexCoord)));
            vec2 k3 = vec2(unpackFloat(texture2D(k3_re, vTexCoord)), unpackFloat(texture2D(k3_im, vTexCoord)));
            vec2 k4 = vec2(unpackFloat(texture2D(k4_re, vTexCoord)), unpackFloat(texture2D(k4_im, vTexCoord)));

            vec2 psi_new = psi + k1/6. + k2/3. + k3/3. + k4/6.;
            //psi_new = psi;
            if (addVortex==1){
                psi_new = cmpxmul(psi_new,vec2(cos(atan(vTexCoord.y-addVortex_y,vTexCoord.x-addVortex_x)),
                            -sin(atan(vTexCoord.y-addVortex_y,vTexCoord.x-addVortex_x))));
            }else if (addVortex==-1){
                psi_new = cmpxmul(psi_new,vec2(cos(-atan(vTexCoord.y-addVortex_y,vTexCoord.x-addVortex_x)),
                            -sin(-atan(vTexCoord.y-addVortex_y,vTexCoord.x-addVortex_x))));
            }
            if (reset==1){
                psi_new = vec2(0.99,0.0);
            }
            if(reim == 0){
                gl_FragColor = packFloat(psi_new.x);
            } else {
                gl_FragColor = packFloat(psi_new.y);
            }
        }
    </script>
  </head>
  <body>
    <h1>WebGL GPE</h1>
    <canvas id="GPE" width="256" height="256"></canvas><br>
    <img src="gpe.svg" width="50%">
    <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
    <script src="dat.gui.js"></script>
    <script src="gpe.js?v=0.04"></script>
  </body>
</html>
